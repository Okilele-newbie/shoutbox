{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Documents\\\\GitHub\\\\shoutbox\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst concatStream = require('concat-stream');\n\nconst Readable = require('stream').Readable;\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs-extra\");\n\nclass SolidFileStorage {\n  constructor() {\n    this.prefix = \"file\";\n    this.name = \"solid-rest-file-storage-1.0.0\";\n  }\n\n  _makeStream(text) {\n    if (typeof text === 'object' && typeof text.stream === 'function') {\n      return text.stream();\n    }\n\n    let s = new Readable();\n    s.push(text);\n    s.push(null);\n    return s;\n  }\n\n  async text(stream) {\n    return new Promise((resolve, reject) => {\n      stream = stream || \"\";\n      if (typeof stream === \"string\") return resolve(stream);\n      stream.pipe(concatStream({\n        encoding: 'string'\n      }, resolve())).catch(e => {\n        console.log(e);\n        reject();\n      });\n      stream.on('error', reject());\n    });\n  }\n\n  async json(stream) {\n    return text(stream).then(text => JSON.parse(text));\n  }\n\n  async getObjectType(fn, options) {\n    let stat;\n\n    try {\n      stat = fs.lstatSync(fn);\n    } catch (err) {}\n\n    let type = stat && stat.isDirectory() ? \"Container\" : \"Resource\";\n    if (!stat && fn.endsWith('/')) type = \"Container\";\n    return Promise.resolve([type, stat]);\n  }\n\n  async getResource(pathname, options, objectType) {\n    return new Promise(resolve => {\n      let fn = pathname.replace(/.*\\//, '');\n      let success = \"\";\n\n      try {\n        fs.createReadStream(pathname).on(\"data\", chunk => {\n          success = success + chunk;\n        }).on(\"error\", err => {\n          console.log(err);\n        }).on(\"end\", () => {\n          return resolve([200, success]);\n        });\n      } catch (e) {}\n    });\n  }\n\n  async putResource(pathname, options) {\n    return new Promise(resolve => {\n      options.body = this._makeStream(options.body);\n      options.body.pipe(fs.createWriteStream(pathname)).on('finish', () => {\n        resolve([201]);\n      }).on('error', err => {\n        if (options.method === \"PUT\" && options.objectType === \"Container\") resolve([405]);\n        resolve([500]);\n      });\n    });\n  }\n\n  async deleteResource(fn) {\n    return new Promise(function (resolve) {\n      fs.unlink(fn, function (err) {\n        if (err) resolve([409]);else resolve([200]);\n      });\n    });\n  }\n\n  deleteContainer(fn) {\n    return new Promise(function (resolve) {\n      fs.rmdir(fn, function (err) {\n        if (err) {\n          resolve([409]);\n        } else {\n          resolve([200]);\n        }\n      });\n    });\n  }\n\n  postContainer(fn, options) {\n    fn = fn.replace(/\\/$/, '');\n    return new Promise(function (resolve) {\n      if (fs.existsSync(fn)) {\n        return resolve([201]);\n      }\n\n      fs.mkdirp(fn, {}, err => {\n        if (err) {\n          return resolve([500]);\n        } else {\n          return resolve([201]);\n        }\n      });\n    });\n  }\n\n  async makeContainers(pathname, options) {\n    let filename = path.basename(pathname);\n    let reg = new RegExp(filename + \"\\$\");\n    let foldername = pathname.replace(reg, '');\n\n    let _ref = await this.getObjectType(foldername),\n        _ref2 = _slicedToArray(_ref, 2),\n        t = _ref2[0],\n        exists = _ref2[1];\n\n    if (exists) return Promise.resolve([200]);\n    foldername = foldername.replace(/\\/$/, '');\n    await fs.mkdirpSync(foldername, {}, err => {\n      if (err) return Promise.resolve(500);else return Promise.resolve(201);\n    });\n    return Promise.resolve([200]);\n  }\n\n  async getContainer(pathname, options) {\n    return fs.readdirSync(pathname);\n  }\n\n}\n\nmodule.exports = SolidFileStorage;","map":null,"metadata":{},"sourceType":"script"}