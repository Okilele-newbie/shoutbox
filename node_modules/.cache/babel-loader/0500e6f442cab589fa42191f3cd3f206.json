{"ast":null,"code":"/**\n * Local dependencies\n */\nconst CryptoKey = require('./keys/CryptoKey');\n\nconst CryptoKeyPair = require('./keys/CryptoKeyPair');\n\nconst JsonWebKey = require('./keys/JsonWebKey');\n\nconst recognizedKeyUsages = require('./keys/recognizedKeyUsages');\n\nconst supportedAlgorithms = require('./algorithms');\n\nconst _require = require('./errors'),\n      InvalidAccessError = _require.InvalidAccessError,\n      NotSupportedError = _require.NotSupportedError;\n\nconst _require2 = require('text-encoding'),\n      TextEncoder = _require2.TextEncoder,\n      TextDecoder = _require2.TextDecoder;\n/**\n * SubtleCrypto\n */\n\n\nclass SubtleCrypto {\n  /**\n   * encrypt\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  encrypt(algorithm, key, data) {\n    data = data.slice();\n    let normalizedAlgorithm = supportedAlgorithms.normalize('encrypt', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (normalizedAlgorithm.name !== key.algorithm.name) {\n        throw new InvalidAccessError('Algorithm does not match key');\n      }\n\n      if (!key.usages.includes('encrypt')) {\n        throw new InvalidAccessError('Key usages must include \"encrypt\"');\n      }\n\n      let ciphertext = normalizedAlgorithm.encrypt(algorithm, key, data);\n      resolve(ciphertext);\n    });\n  }\n  /**\n   * decrypt\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  decrypt(algorithm, key, data) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('decrypt', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    data = data.slice();\n    return new Promise((resolve, reject) => {\n      if (normalizedAlgorithm.name !== key.algorithm.name) {\n        throw new InvalidAccessError('Algorithm does not match key');\n      }\n\n      if (!key.usages.includes('decrypt')) {\n        throw new InvalidAccessError('Key usages must include \"decrypt\"');\n      }\n\n      let plaintext = normalizedAlgorithm.decrypt(algorithm, key, data);\n      resolve(plaintext);\n    });\n  }\n  /**\n   * sign\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  sign(algorithm, key, data) {\n    data = data.slice();\n    let normalizedAlgorithm = supportedAlgorithms.normalize('sign', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (normalizedAlgorithm.name !== key.algorithm.name) {\n        throw new InvalidAccessError('Algorithm does not match key');\n      }\n\n      if (!key.usages.includes('sign')) {\n        throw new InvalidAccessError('Key usages must include \"sign\"');\n      }\n\n      let result = normalizedAlgorithm.sign(key, data);\n      resolve(result);\n    });\n  }\n  /**\n   * verify\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} key\n   * @param {BufferSource} signature\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  verify(alg, key, signature, data) {\n    signature = signature.slice();\n    let normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    data = data.slice();\n    return new Promise((resolve, reject) => {\n      if (normalizedAlgorithm.name !== key.algorithm.name) {\n        throw new InvalidAccessError('Algorithm does not match key');\n      }\n\n      if (!key.usages.includes('verify')) {\n        throw new InvalidAccessError('Key usages must include \"verify\"');\n      }\n\n      let result = normalizedAlgorithm.verify(key, signature, data);\n      resolve(result);\n    });\n  }\n  /**\n   * digest\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {BufferSource} data\n   *\n   * @returns {Promise.<ArrayBuffer>}\n   */\n\n\n  digest(algorithm, data) {\n    data = data.slice();\n    let normalizedAlgorithm = supportedAlgorithms.normalize('digest', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        let result = normalizedAlgorithm.digest(algorithm, data);\n        return resolve(result);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n  /**\n   * generateKey\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {Boolean} extractable\n   * @param {Array} keyUsages\n   *\n   * @returns {Promise}\n   */\n\n\n  generateKey(algorithm, extractable, keyUsages) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('generateKey', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        let result = normalizedAlgorithm.generateKey(algorithm, extractable, keyUsages);\n\n        if (result instanceof CryptoKey) {\n          let type = result.type,\n              usages = result.usages;\n          let restricted = type === 'secret' || type === 'private';\n          let emptyUsages = !usages || usages.length === 0;\n\n          if (restricted && emptyUsages) {\n            throw new SyntaxError();\n          }\n        }\n\n        if (result instanceof CryptoKeyPair) {\n          let usages = result.privateKey.usages;\n\n          if (!usages || usages.length === 0) {\n            throw new SyntaxError();\n          }\n        }\n\n        resolve(result);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n  /**\n   * deriveKey\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} baseKey\n   * @param {AlgorithmIdentifier} derivedKeyType\n   * @param {Boolean} extractable\n   * @param {Array} keyUsages\n   * @returns {Promise}\n   */\n\n\n  deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {\n    return new Promise();\n  }\n  /**\n   * deriveBits\n   *\n   * @description\n   *\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {CryptoKey} baseKey\n   * @param {number} length\n   *\n   * @returns {Promise}\n   */\n\n\n  deriveBits(algorithm, baseKey, length) {\n    return new Promise();\n  }\n  /**\n   * importKey\n   *\n   * @description\n   *\n   * @param {KeyFormat} format\n   * @param {BufferSource|JWK} keyData\n   * @param {AlgorithmIdentifier} algorithm\n   * @param {Boolean} extractable\n   * @param {Array} keyUsages\n   *\n   * @returns {Promise}\n   */\n\n\n  importKey(format, keyData, algorithm, extractable, keyUsages) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('importKey', algorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (format === 'raw' || format === 'pkcs8' || format === 'spki') {\n        if (keyData instanceof JsonWebKey) {\n          throw new TypeError();\n        }\n\n        keyData = keyData.slice();\n      }\n\n      if (format === 'jwk') {\n        keyData = new JsonWebKey(keyData);\n\n        if (!(keyData instanceof JsonWebKey)) {\n          throw new TypeError('key is not a JSON Web Key');\n        }\n      }\n\n      try {\n        let result = normalizedAlgorithm.importKey(format, keyData, algorithm, extractable, keyUsages);\n\n        if (result.type === 'secret' || result.type === 'private') {\n          if (!result.usages || result.usages.length === 0) {\n            throw new SyntaxError();\n          }\n        }\n\n        result.extractable = extractable;\n        result.usages = recognizedKeyUsages.normalize(keyUsages);\n        resolve(result);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n  /**\n   * exportKey\n   *\n   * @description\n   *\n   * @param {KeyFormat} format\n   * @param {CryptoKey} key\n   *\n   * @returns {Promise}\n   */\n\n\n  exportKey(format, key) {\n    return new Promise((resolve, reject) => {\n      try {\n        let registeredAlgorithms = supportedAlgorithms['exportKey'];\n\n        if (!registeredAlgorithms[key.algorithm.name]) {\n          throw new NotSupportedError(key.algorithm.name);\n        }\n\n        if (key.extractable === false) {\n          throw new InvalidAccessError('Key is not extractable');\n        }\n\n        let result = key.algorithm.exportKey(format, key);\n        resolve(result);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n  /**\n   * wrapKey\n   *\n   * @description\n   *\n   * @param {KeyFormat} format\n   * @param {CryptoKey} key\n   * @param {CryptoKey} wrappingKey\n   * @param {AlgorithmIdentifier} wrapAlgorithm\n   *\n   * @returns {Promise}\n   */\n\n\n  wrapKey(format, key, wrappingKey, wrapAlgorithm) {\n    // 1. Parameters\n    // 2. Setup normalizedAlgorithm with op as 'unwrap'\n    let normalizedAlgorithm = supportedAlgorithms.normalize('wrapKey', wrapAlgorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      // 3. If failed, then try again with op as 'encrypt'\n      normalizedAlgorithm = supportedAlgorithms.normalize('encrypt', wrapAlgorithm);\n    } // 4. Otherwise reject outright\n\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    } // 5-6. Setup and asynchronously return a new promise\n\n\n    return new Promise((resolve, reject) => {\n      // 7. Try catch the following step...\n      // if anything goes wrong then reject the promise outright\n      try {\n        // 8. Validate normalizedAlgorithm name property\n        if (normalizedAlgorithm.name !== wrappingKey.algorithm.name) {\n          throw new InvalidAccessError('NormalizedAlgorthm name must be same as wrappingKey algorithm name');\n        } // 9. Validate usages property contains wrap\n\n\n        if (!wrappingKey.usages.includes('wrapKey')) {\n          throw new InvalidAccessError('Wrapping key usages must include \"wrapKey\"');\n        } // 10. Validate algorithm contains exportKey\n\n\n        let exportKeyAlgorithms = supportedAlgorithms['exportKey'];\n\n        if (!exportKeyAlgorithms[key.algorithm.name]) {\n          throw new NotSupportedError(key.algorithm.name);\n        } // 11. Validate extractable property\n\n\n        if (key.extractable === false) {\n          throw new InvalidAccessError('Key is not extractable');\n        } // 12. Generate extracted key\n\n\n        return this.exportKey(format, key).then(exportedKey => {\n          let bytes; // 13.1. If format is \"raw\", \"pkcs8\", or \"spki\":\n\n          if ([\"raw\", \"pkcs8\", \"spki\"].includes(format)) {\n            bytes = exportedKey;\n          } // 13.2. If format is \"jwk\"\n          else if (format === \"jwk\") {\n              let json = JSON.stringify(exportedKey);\n              bytes = new TextEncoder().encode(json);\n            } // 14.1. If the normalizedAlgorithm supports wrapKey then use it\n\n\n          if (normalizedAlgorithm['wrapKey']) {\n            return normalizedAlgorithm.wrapKey(format, bytes, wrappingKey, wrapAlgorithm);\n          } // 14.2. Otherwise try with encrypt\n          else if (normalizedAlgorithm['encrypt']) {\n              return normalizedAlgorithm.encrypt(wrapAlgorithm, wrappingKey, new Uint8Array(bytes));\n            } // 14.3. Otherwise throw error\n            else {\n                return reject(new NotSupportedError(normalizedAlgorithm.name));\n              }\n        }) // 15. Return the resulting promise\n        .then(resolve);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n  /**\n   * unwrapKey\n   *\n   * @description\n   *\n   * @param {KeyFormat} format\n   * @param {BufferSource} wrappedKey\n   * @param {CryptoKey} unwrappingKey\n   * @param {AlgorithmIdentifier} unwrapAlgorithm\n   * @param {AlgorithmIdentifier} unwrappedKeyAlgorithm\n   * @param {Boolean} extractable\n   * @param {Array} keyUsages\n   *\n   * @returns {Promise}\n   */\n\n\n  unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {\n    // 1. Parameters\n    // 2. Ommited due to redundancy\n    // 3. Setup normalizedAlgorithm with op as 'unwrap'\n    let normalizedAlgorithm = supportedAlgorithms.normalize('unwrapKey', unwrapAlgorithm);\n\n    if (normalizedAlgorithm instanceof Error) {\n      // 4. If failed, then try again with op as 'encrypt'\n      normalizedAlgorithm = supportedAlgorithms.normalize('decrypt', unwrapAlgorithm);\n    } // 5. Otherwise reject outright\n\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(normalizedAlgorithm);\n    } // 6. Setup normalizedKeyAlgorithm\n\n\n    let normalizedKeyAlgorithm = supportedAlgorithms.normalize('importKey', unwrappedKeyAlgorithm);\n\n    if (normalizedKeyAlgorithm instanceof Error) {\n      // 7. If failed, then try again with op as 'encrypt'\n      return Promise.reject(normalizedKeyAlgorithm);\n    } // 8-9. Setup and asynchronously return a new promise\n\n\n    return new Promise((resolve, reject) => {\n      // 10. Try catch the following step...\n      // if anything goes wrong then reject the promise outright\n      try {\n        // 11. Validate normalizedAlgorithm name property\n        if (normalizedAlgorithm.name !== unwrappingKey.algorithm.name) {\n          throw new InvalidAccessError('NormalizedAlgorthm name must be same as unwrappingKey algorithm name');\n        } // 12. Validate usages property contains unwrap\n\n\n        if (!unwrappingKey.usages.includes('unwrapKey')) {\n          throw new InvalidAccessError('Unwrapping key usages must include \"unwrapKey\"');\n        }\n\n        let key; // 13.1. If the normalizedAlgorithm supports unwrapKey then use it\n\n        if (normalizedAlgorithm['unwrapKey']) {\n          key = normalizedAlgorithm.unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages);\n        } // 13.2. Otherwise try with decrypt\n        else if (normalizedAlgorithm['decrypt']) {\n            key = normalizedAlgorithm.decrypt(unwrapAlgorithm, unwrappingKey, wrappedKey);\n          } // 13.3. Otherwise throw error\n          else {\n              return reject(new NotSupportedError(normalizedAlgorithm.name));\n            }\n\n        let bytes; // 14.1. If format is \"raw\", \"pkcs8\", or \"spki\":\n\n        if ([\"raw\", \"pkcs8\", \"spki\"].includes(format)) {\n          bytes = key;\n        } // 14.2. If format is \"jwk\"\n        else if (format === \"jwk\") {\n            bytes = JSON.parse(new TextDecoder().decode(key));\n          } // 15. Import the resulting unwrapped content\n        // 16-18. Ommitted because it is handled by importKey interface\n\n\n        let result = normalizedKeyAlgorithm.importKey(format, bytes, unwrappedKeyAlgorithm, extractable, keyUsages); // 19. Resolve the result\n\n        return resolve(result);\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = SubtleCrypto;","map":null,"metadata":{},"sourceType":"script"}