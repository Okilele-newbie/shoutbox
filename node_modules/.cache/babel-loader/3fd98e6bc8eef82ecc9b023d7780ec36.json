{"ast":null,"code":"/* \n   constructor should define the pacakage's name \n   by default this will be added to the x-powered-by header of all responses\n*/\nclass SolidLocalStorage {\n  constructor() {\n    this.prefix = \"ls\";\n    this.name = \"solid-rest-localStorage-1.0.0\";\n    localStorage.setItem(\"/\", \" \");\n  }\n  /*\n     getObjectType(pathname,options)\n       * trys to find pathname in storage\n       * if found, sets exists to true\n       * sets type to \"Container\" or \"Resource\" or undefined\n       * returns an array [type,exists]\n  */\n\n\n  async getObjectType(pathname, options) {\n    let type = pathname.match(/\\/$/) ? \"Container\" : \"Resource\";\n    pathname = pathname.replace(/\\/$/, ''); // REMOVE TRAILING SLASH\n\n    let exists = false;\n    let keys = Object.keys(localStorage);\n\n    for (var k in keys) {\n      let item = keys[k];\n\n      if (type === \"Container\" && item.startsWith(pathname)) {\n        exists = true;\n        break;\n      }\n\n      if (item === pathname) {\n        exists = true;\n        break;\n      }\n    }\n\n    return [type, exists];\n  }\n  /*\n    getResource(pathname,options)\n      * gets a resource\n      * on success, returns [ 200, resourceContents, optionalHeader ]\n      * on failure, returns [ 500, undefined, optionalHeader ]\n  */\n\n\n  async getResource(pathname, options) {\n    try {\n      let body = localStorage.getItem(pathname);\n      return Promise.resolve([200, body]);\n    } catch (e) {\n      Promise.resolve([500]);\n    }\n  }\n  /*\n    getContainer(pathname,options)\n      * returns an array of the container's contained resource names\n      * OR returns a turtle representation of the container and contents\n  */\n\n\n  async getContainer(pathname, options) {\n    const files = Object.keys(localStorage).filter(path => path.startsWith(pathname) && path != pathname) // Only children\n    .map(path => path.substr(pathname.length)).filter(path => !path.slice(0, -1).includes(\"/\")); // Only include direct children\n\n    return files;\n  }\n\n  dump(pathname, options) {\n    let keys = Object.keys(localStorage).filter(k => {\n      if (!k.match(/(setItem|getItem|removeItem)/)) return k;\n    }).map(m => {\n      console.log(m, localStorage.getItem(m));\n    });\n  }\n\n  clear() {\n    let keys = Object.keys(localStorage).filter(k => {\n      if (!k.match(/(setItem|getItem|removeItem)/)) return k;\n    }).map(item => {\n      this.deleteResource(item);\n    });\n  }\n  /*\n     putResource(pathname,options)\n       * creates a single Resource\n       * on success : status = 201\n       * on error : status = 500\n       * returns [status,undefined,optionalHeader]\n  */\n\n\n  async putResource(pathname, options) {\n    options = options || {};\n    options.body = options.body || \"\";\n\n    try {\n      localStorage.setItem(pathname, options.body);\n      return Promise.resolve([201]);\n    } catch (e) {\n      console.log(e);\n      return Promise.resolve([500]);\n    }\n  }\n  /*\n     postContainer(pathname,options)\n        * creates a single Container\n        * on success : status = 201\n        * on error : status = 500\n        * returns [status,undefined,optionalHeader]\n  */\n\n\n  async postContainer(pathname, options) {\n    pathname = pathname + '/'; // because wasn't on slug\n\n    return this.putResource(pathname, options);\n  }\n  /*\n    deleteResource(pathname,options)\n      * deletes a resource\n      * on success, returns [200,undefined,optionalHeader]\n      * on failure, returns [500,undefined,optionalHeader]\n  */\n\n\n  async deleteResource(pathname, options) {\n    try {\n      localStorage.removeItem(pathname);\n      return Promise.resolve([200]);\n    } catch (e) {\n      return Promise.resolve([500]);\n    }\n  }\n  /*\n    deleteContainer(pathname,options)\n      * if container is not empty, returns [409,undefined,optionalHeader]\n      * else deletes container\n      * on success, returns [200,undefined,optionalHeader]\n      * on failure, returns [500,undefined,optionalHeader]\n  */\n\n\n  async deleteContainer(pathname, options) {\n    let files = await this.getContainer(pathname, options);\n\n    if (files.length) {\n      return Promise.resolve([409]);\n    }\n\n    return await this.deleteResource(pathname, options);\n  }\n\n  async makeContainers(pathname, options) {\n    const inexistentParents = []; // Get all parents which need to be created\n\n    let curParent = getParent(pathname);\n\n    while (curParent && !(await this.getObjectType(curParent))[1]) {\n      inexistentParents.push(curParent);\n      curParent = getParent(curParent);\n    }\n\n    if (!curParent) // Should not happen, that we get to the root\n      return [500]; // Create missing parents\n\n    while (inexistentParents.length) {\n      // postContainer expects an url without '/' at the end\n      await this.postContainer(inexistentParents.pop().slice(0, -1));\n    }\n\n    return [201];\n  }\n\n}\n/**\n * return parent url with / at the end.\n * If no parent exists return null\n * @param {string} url \n * @returns {string|null}\n */\n\n\nfunction getParent(url) {\n  while (url.endsWith('/')) url = url.slice(0, -1);\n\n  if (!url.includes('/')) return null;\n  return url.substring(0, url.lastIndexOf('/')) + '/';\n}\n/* \n  OPTIONAL METHODS\n\n  see solid-rest.js code for examples of the defaults\n  optionally provide your own to replace or augment the behavior\n\n   text(stream)\n     * response method to pipe text body\n     * receives response body, returns piped string\n   json(string)\n     * response method to parse json body\n     * receives response body returns a json object\n   container2turtle(pathname,options,contentsArray)\n     * iterates over container's contents, creates a turtle representation\n     * returns [200, turtleContents, optionalHeader]\n   getHeaders(pathname,options)\n     * returns header fields to replace or augment default headers\n*/\n\n/*\n  if it should work in nodejs, export the object\n*/\n\n\nif (typeof window === \"undefined\") {\n  alert = msg => console.log(msg);\n\n  localStorage = {\n    getItem: key => {\n      return localStorage[key];\n    },\n    removeItem: key => {\n      delete localStorage[key];\n    },\n    setItem: (key, val) => {\n      localStorage[key] = val;\n    }\n  };\n  module.exports = SolidLocalStorage;\n}","map":null,"metadata":{},"sourceType":"script"}