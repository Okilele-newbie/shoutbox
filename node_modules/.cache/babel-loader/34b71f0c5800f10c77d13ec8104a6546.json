{"ast":null,"code":"'use strict';\n\nconst fetch = require('node-fetch');\n\nconst onHttpError = require('./onHttpError');\n\nconst PoPToken = require('./PoPToken');\n\nclass Session {\n  /**\n   * @param options {Object}\n   *\n   * @param options.credentialType {string} 'access_token' or 'pop_token'\n   *\n   * @param options.issuer {string} Identity provider (issuer of ID/Access Token)\n   *\n   * @param options.authorization {object}\n   * @param options.authorization.client_id {string} OIDC/OAuth2 client id\n   * @param [options.authorization.id_token] {string} Compact-serialized id_token param\n   * @param [options.authorization.access_token] {string} Compact-serialized access_token param\n   * @param [options.authorization.refresh_token] {string} Compact-serialized refresh_token\n   *\n   * @param [options.sessionKey] {string} Serialized client session key generated\n   *   during the Authentication Request, used to issue PoPTokens\n   *\n   * @param [options.idClaims] {object} Decoded/verified ID Token JWT payload\n   *\n   * @param [options.accessClaims] {object} Decoded/verified Access Token JWT payload\n   */\n  constructor(options) {\n    this.credentialType = options.credentialType || 'access_token';\n    this.issuer = options.issuer;\n    this.authorization = options.authorization || {};\n    this.sessionKey = options.sessionKey;\n    this.idClaims = options.idClaims;\n    this.accessClaims = options.accessClaims;\n  }\n\n  static from(options) {\n    return new Session(options);\n  }\n  /**\n   * @param response {AuthenticationResponse}\n   *\n   * @returns {Session} RelyingParty Session object\n   */\n\n\n  static fromAuthResponse(response) {\n    const RelyingParty = require('./RelyingParty'); // import here due to circular dep\n\n\n    let idClaims = response.decoded && response.decoded.payload || {};\n    let rp = response.rp;\n    let registration = rp.registration;\n    let rpAuthOptions = rp.defaults.authenticate || {};\n    let credentialType = rpAuthOptions['credential_type'] || rp.defaults.popToken ? 'pop_token' : 'access_token';\n    let sessionKey = response.session[RelyingParty.SESSION_PRIVATE_KEY];\n    let options = {\n      credentialType,\n      sessionKey,\n      issuer: idClaims.iss,\n      idClaims,\n      authorization: {\n        client_id: registration['client_id'],\n        access_token: response.params['access_token'],\n        id_token: response.params['id_token'],\n        refresh_token: response.params['refresh_token']\n      }\n    };\n    return Session.from(options);\n  }\n  /**\n   * Authenticated fetch() getter\n   *\n   * @returns {function}\n   */\n\n\n  get fetch() {\n    /**\n     * fetch() function signature\n     *\n     * @param url {RequestInfo|string}\n     * @param options {object}\n     *\n     * @returns {Function<Promise<Response>>}\n     */\n    return (url, options) => {\n      return Promise.resolve().then(() => {\n        if (this.hasCredentials()) {\n          return this.fetchWithCredentials(url, options);\n        } else {\n          return fetch(url, options);\n        }\n      }).then(onHttpError('Error while fetching resource'));\n    };\n  }\n  /**\n   * bearerTokenFor\n   *\n   * @param url {string}\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  bearerTokenFor(url) {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return PoPToken.issueFor(url, this);\n\n      default:\n        // 'access_token' etc\n        return Promise.resolve(this.authorization[this.credentialType]);\n    }\n  }\n  /**\n   * hasCredentials\n   *\n   * @returns {boolean}\n   */\n\n\n  hasCredentials() {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return !!this.authorization['id_token'];\n\n      default:\n        // 'access_token' etc\n        return !!this.authorization[this.credentialType];\n    }\n  }\n  /**\n   * fetchWithCredentials\n   *\n   * @param url {RequestInfo|string}\n   * @param options {object}\n   *\n   * @returns {Promise<Response>}\n   */\n\n\n  fetchWithCredentials(url, options = {}) {\n    options.headers = options.headers || {};\n    return this.bearerTokenFor(url).then(token => {\n      options.headers.authorization = \"Bearer \".concat(token);\n      return fetch(url, options);\n    });\n  }\n\n}\n\nmodule.exports = Session;","map":null,"metadata":{},"sourceType":"script"}