{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Documents\\\\GitHub\\\\shoutbox\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst Url = require('url');\n\nconst path = require(\"path\");\n\nconst _require = require('node-fetch'),\n      Response = _require.Response;\n\nconst contentTypeLookup = require('mime-types').contentType;\n\nclass SolidRest {\n  constructor(handlers) {\n    this.storageHandlers = {};\n    handlers.forEach(handler => {\n      this.storageHandlers[handler.prefix] = handler;\n    });\n  }\n\n  storage(options) {\n    if (!this.storageHandlers[options.rest_prefix]) throw \"Did not recognize prefix \" + options.rest_prefix;\n    return this.storageHandlers[options.rest_prefix];\n  }\n\n  async fetch(uri, options) {\n    const self = this;\n    options = Object.assign({}, options);\n    options.headers = options.headers || {};\n    options.url = decodeURIComponent(uri);\n    let pathname = decodeURIComponent(Url.parse(uri).pathname);\n    options.method = (options.method || options.Method || 'GET').toUpperCase();\n    let scheme = Url.parse(uri).protocol;\n    let prefix = scheme.match(\"file\") ? 'file' : uri.replace(scheme + '//', '').replace(/\\/.*/, '');\n    options.scheme = scheme;\n    options.rest_prefix = prefix;\n\n    const _ref = await self.storage(options).getObjectType(pathname, options),\n          _ref2 = _slicedToArray(_ref, 2),\n          objectType = _ref2[0],\n          objectExists = _ref2[1];\n\n    options.objectType = objectType;\n    options.objectExists = objectExists;\n    const notFoundMessage = '404 Not Found';\n    /* GET\n    */\n\n    if (options.method === 'GET') {\n      if (!objectExists) return _response(notFoundMessage, options, 404);\n\n      if (objectType === \"Container\") {\n        let contents = await self.storage(options).getContainer(pathname, options);\n\n        const _ref3 = await _container2turtle(pathname, options, contents),\n              _ref4 = _slicedToArray(_ref3, 3),\n              status = _ref4[0],\n              turtleContents = _ref4[1],\n              headers = _ref4[2];\n\n        Object.assign(options.headers, headers);\n        return _response(turtleContents, options, status);\n      } else if (objectType === \"Resource\") {\n        const _ref5 = await self.storage(options).getResource(pathname, options),\n              _ref6 = _slicedToArray(_ref5, 3),\n              status = _ref6[0],\n              contents = _ref6[1],\n              headers = _ref6[2];\n\n        Object.assign(options.headers, headers);\n        return _response(contents, options, status);\n      }\n    }\n    /* HEAD\n    */\n\n\n    if (options.method === 'HEAD') {\n      if (!objectExists) return _response(null, options, 404);else return _response(null, options, 200);\n    }\n    /* DELETE\n    */\n\n\n    if (options.method === \"DELETE\") {\n      if (!objectExists) return _response(notFoundMessage, options, 404);\n\n      if (objectType === \"Container\") {\n        const _ref7 = await self.storage(options).deleteContainer(pathname, options),\n              _ref8 = _slicedToArray(_ref7, 3),\n              status = _ref8[0],\n              headers = _ref8[2];\n\n        Object.assign(options.headers, headers);\n        return _response(null, options, status);\n      } else if (objectType === 'Resource') {\n        const _ref9 = await self.storage(options).deleteResource(pathname, options),\n              _ref10 = _slicedToArray(_ref9, 3),\n              status = _ref10[0],\n              headers = _ref10[2];\n\n        Object.assign(options.headers, headers);\n        return _response(null, options, status);\n      } else {}\n    }\n    /* POST\n    */\n\n\n    if (options.method === \"POST\") {\n      if (!objectExists) return _response(notFoundMessage, options, 404);\n      let link = options.headers.Link || options.headers.link;\n      let slug = options.headers.Slug || options.headers.slug;\n      if (slug.match(/\\//)) return _response(null, options, 400); // Now returns 400 instead of 404\n\n      pathname = path.join(pathname, slug);\n\n      if (link && link.match(\"Container\")) {\n        const _ref11 = await self.storage(options).postContainer(pathname, options),\n              _ref12 = _slicedToArray(_ref11, 3),\n              status = _ref12[0],\n              headers = _ref12[2];\n\n        Object.assign(options.headers, headers);\n        return _response(null, options, status);\n      } else if (link && link.match(\"Resource\")) {\n        const _ref13 = await self.storage(options).putResource(pathname, options),\n              _ref14 = _slicedToArray(_ref13, 3),\n              status = _ref14[0],\n              headers = _ref14[2];\n\n        Object.assign(options.headers, headers);\n        return _response(null, options, status);\n      }\n    }\n    /* PUT\n    */\n\n\n    if (options.method === 'PUT') {\n      if (objectType === \"Container\") return _response(null, options, 409);\n\n      const _ref15 = await self.storage(options).makeContainers(pathname, options),\n            _ref16 = _slicedToArray(_ref15, 3),\n            status = _ref16[0],\n            undefined = _ref16[1],\n            headers = _ref16[2];\n\n      Object.assign(options.headers, headers);\n      if (status !== 200 && status !== 201) return _response(null, options, status);\n\n      const _ref17 = await self.storage(options).putResource(pathname, options),\n            _ref18 = _slicedToArray(_ref17, 3),\n            putStatus = _ref18[0],\n            putHeaders = _ref18[2];\n\n      Object.assign(options.headers, putHeaders); // Note: The headers from makeContainers are also returned here\n\n      return _response(null, options, putStatus);\n    } else {\n      return _response(null, options, 405);\n    }\n    /**\n     * @param {RequestInfo} body \n     * @param {RequestInit} options \n     * @param {Number} status - Overrules options.status\n     */\n\n\n    function _response(body, options, status = options.status) {\n      options.status = status;\n      options.headers = Object.assign(_getHeaders(pathname, options), options.headers);\n      return new Response(body, options);\n    }\n\n    async function _container2turtle(pathname, options, contentsArray) {\n      if (typeof self.storage(options).container2turtle != \"undefined\") return self.storage(options).container2turtle(pathname, options, contentsArray);\n      let filenames = contentsArray.filter(item => {\n        if (!item.endsWith('.acl') && !item.endsWith('.meta')) {\n          return item;\n        }\n      });\n      if (!pathname.endsWith(\"/\")) pathname += \"/\";\n      let str2 = \"\";\n      let str = \"@prefix ldp: <http://www.w3.org/ns/ldp#>.\\n\" + \"<> a ldp:BasicContainer, ldp:Container\";\n\n      if (filenames.length) {\n        str = str + \"; ldp:contains\\n\";\n\n        for (var i = 0; i < filenames.length; i++) {\n          let fn = filenames[i];\n\n          let _ref19 = await self.storage(options).getObjectType(pathname + fn),\n              _ref20 = _slicedToArray(_ref19, 2),\n              ftype = _ref20[0],\n              e = _ref20[1];\n\n          if (ftype === \"Container\" && !fn.endsWith(\"/\")) fn = fn + \"/\"; //        let prefix = options.rest_prefix===\"file\" ? \"\" : options.rest_prefix\n          //        fn = options.scheme+\"//\"+prefix+pathname + fn\n\n          str = str + \"  <\".concat(fn, \">,\\n\");\n          ftype = ftype === \"Container\" ? \"a ldp:Container; a ldp:BasicContainer.\" : \"a ldp:Resource.\";\n          str2 = str2 + \"  <\".concat(fn, \"> \").concat(ftype, \"\\n\");\n        }\n\n        str = str.replace(/,\\n$/, \"\");\n      }\n\n      str = str + \".\\n\" + str2; // str = _makeStream(str);\n\n      return [200, str];\n    }\n    /* DEFAULT HEADER\n         link created using .meta and .acl appended to uri \n         content-type assigned by mime-types.lookup\n         date from nodejs Date\n    */\n\n\n    function _getHeaders(pathname, options) {\n      let fn = pathname.replace(/.*\\//, '');\n      let headers = typeof self.storage(options).getHeaders != \"undefined\" ? self.storage(options).getHeaders(pathname, options) : {};\n      headers.location = headers.location || options.url;\n      headers.date = headers.date || new Date(Date.now()).toISOString();\n      headers.allow = headers.allow || ['OPTIONS, HEAD, GET, PATCH, POST, PUT, DELETE'];\n      headers['x-powered-by'] = headers['x-powered-by'] || self.storage(options).name;\n      headers.link = headers.link || options.objectType === \"Container\" ? \"<.meta>; rel=\\\"describedBy\\\", <.acl>; rel=\\\"acl\\\",\" + \"<http://www.w3.org/ns/ldp#Container>; rel=\\\"type\\\",\" + \"<http://www.w3.org/ns/ldp#BasicContainer>; rel=\\\"type\\\"\" : \"<\".concat(fn, \".meta>; rel=\\\"describedBy\\\", <\").concat(fn, \".acl>; rel=\\\"acl\\\",\") + \"<http://www.w3.org/ns/ldp#Resource>; rel=\\\"type\\\"\";\n      headers['content-type'] = headers['content-type'] || options.objectType === \"Container\" ? \"text/turtle\" : contentTypeLookup(path.extname(pathname));\n      if (!headers['content-type']) delete headers['content-type'];\n      return headers;\n    } // end of getHeaders()\n\n  } // end of fetch()\n\n\n} // end of SolidRest()\n\n\nmodule.exports = exports = SolidRest;\n/* END */\n\n/*\nrequired\n  getObjectType\n  getResouce\n  getContainer\n  putResource\n  postResource\n  postContainer\n  deleteResource\n  deleteContainer\n  makeContainers\noptional\n  getHeaders\n  text\n  json\n*/","map":null,"metadata":{},"sourceType":"script"}