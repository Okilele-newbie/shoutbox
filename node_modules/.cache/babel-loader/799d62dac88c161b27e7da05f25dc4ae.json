{"ast":null,"code":"/**\n * Module dependencies\n */\nconst legacyCrypto = require('crypto');\n\nconst SubtleCrypto = require('./SubtleCrypto');\n\nconst _require = require('./errors'),\n      QuotaExceededError = _require.QuotaExceededError,\n      TypeMismatchError = _require.TypeMismatchError;\n/**\n * integerTypes\n */\n\n\nconst integerTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array];\n/**\n * integerGetByConstructor\n */\n\nconst integerGetByConstructor = {\n  'Int8Array': 'getInt8',\n  'Uint8Array': 'getUint8',\n  'Int16Array': 'getInt16',\n  'Uint16Array': 'getUint16',\n  'Int32Array': 'getInt32',\n  'Uint32Array': 'getUint32'\n  /**\n   * Crypto interface\n   */\n\n};\n\nclass Crypto {\n  /**\n   * getRandomValues\n   */\n  getRandomValues(typedArray) {\n    if (!integerTypes.some(type => typedArray instanceof type)) {\n      throw new TypeMismatchError();\n    }\n\n    let byteLength = typedArray.byteLength;\n\n    if (byteLength > 65536) {\n      throw new QuotaExceededError();\n    }\n\n    let type = typedArray.constructor;\n    let method = integerGetByConstructor[type.name];\n    let totalBytes = byteLength * typedArray.length;\n    let buffer = legacyCrypto.randomBytes(totalBytes);\n    let arrayBuffer = new Uint8Array(buffer);\n    let dataView = new DataView(arrayBuffer.buffer);\n\n    for (let byteIndex = 0; byteIndex < totalBytes; byteIndex += byteLength) {\n      let integer = dataView[method](byteIndex);\n      let arrayIndex = byteIndex / byteLength;\n      typedArray[arrayIndex] = integer;\n    }\n\n    return typedArray;\n  }\n  /**\n   * subtle\n   */\n\n\n  get subtle() {\n    return new SubtleCrypto();\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = Crypto;","map":null,"metadata":{},"sourceType":"script"}