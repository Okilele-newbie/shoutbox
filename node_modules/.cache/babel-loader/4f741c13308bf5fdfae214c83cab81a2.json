{"ast":null,"code":"const _require = require('url'),\n      URL = _require.URL,\n      resolve = _require.resolve,\n      parseUrl = _require.parse;\n\nconst https = require('https');\n\nconst querystring = require('querystring');\n\nconst RelyingParty = require('@solid/oidc-rp');\n\nconst PoPToken = require('@solid/oidc-rp/lib/PoPToken'); // Fake redirect URL\n\n\nconst redirectUrl = 'http://example.org/';\n\nclass SolidClient {\n  constructor({\n    identityManager\n  }) {\n    this._identityManager = identityManager;\n  }\n  /**\n   * Logs the user in with the given identity provider\n   *\n   * @param identityProvider string The URL of the identity provider\n   * @param credentials object An object with username and password keys\n   *\n   * @returns Promise<Session> A session for the given user\n   */\n\n\n  async login(identityProvider, credentials) {\n    // Obtain a relying party\n    const relyingParty = await this.getRelyingParty(identityProvider); // Load or create a session\n\n    const username = credentials.username;\n\n    let session = this._identityManager.getSession(relyingParty, username);\n\n    if (!session || this.isExpired(session)) {\n      session = await this.createSession(relyingParty, credentials);\n\n      this._identityManager.addSession(relyingParty, username, session);\n    }\n\n    return session;\n  }\n  /**\n   * Logs the user in with the given identity provider\n   *\n   * @param relyingParty RelyingParty The relying party\n   * @param credentials object An object with username and password keys\n   *\n   * @returns Promise<Session> A session for the given user\n   */\n\n\n  async createSession(relyingParty, credentials) {\n    // Obtain the authorization URL\n    const authData = {};\n    const authUrl = await relyingParty.createRequest({\n      redirect_uri: redirectUrl\n    }, authData); // Perform the login\n\n    const loginParams = await this.getLoginParams(authUrl);\n    const accessUrl = await this.performLogin(loginParams.loginUrl, loginParams, credentials);\n    const session = await relyingParty.validateResponse(accessUrl, authData);\n    return session;\n  }\n  /**\n   * Creates an access token for the given URL.\n   *\n   * @param url string\n   * @param session Session\n   *\n   * @returns Promise<string> An access token\n   */\n\n\n  async createToken(url, session) {\n    return PoPToken.issueFor(url, session);\n  }\n  /**\n   * Obtains a relying party for the given identity provider.\n   *\n   * @param identityProvider string The URL of the identity provider\n   *\n   * @returns Promise<RelyingParty> A relying party\n   */\n\n\n  async getRelyingParty(identityProvider) {\n    // Try to load an existing relying party\n    let relyingParty;\n\n    const providerSettings = this._identityManager.getProviderSettings(identityProvider);\n\n    if (providerSettings) {\n      relyingParty = RelyingParty.from(providerSettings);\n    } // Create a new relying party\n    else {\n        relyingParty = await this.registerRelyingParty(identityProvider);\n\n        this._identityManager.addProviderSettings(relyingParty);\n      }\n\n    return relyingParty;\n  }\n  /**\n   * Registers a relying party for the given identity provider.\n   *\n   * @param identityProvider string The URL of the identity provider\n   *\n   * @returns Promise<RelyingParty> A relying party\n   */\n\n\n  async registerRelyingParty(identityProvider) {\n    const responseType = 'id_token token';\n    const registration = {\n      issuer: identityProvider,\n      grant_types: ['implicit'],\n      redirect_uris: [redirectUrl],\n      response_types: [responseType],\n      scope: 'openid profile'\n    };\n    const options = {\n      defaults: {\n        authenticate: {\n          redirect_uri: redirectUrl,\n          response_type: responseType\n        }\n      }\n    };\n    return RelyingParty.register(identityProvider, registration, options);\n  }\n  /**\n   * Obtains the login parameters through the given authentication URL.\n   *\n   * @param authUrl String The authentication URL\n   *\n   * @returns Promise<object> A key/value object of login parameters\n   */\n\n\n  async getLoginParams(authUrl) {\n    // Retrieve the login page in HTML\n    const authorizationPage = await this.fetch(authUrl);\n    const loginPageUrl = resolve(authUrl, authorizationPage.headers.location);\n    const loginPage = await this.fetch(loginPageUrl); // Extract the password form's target URL\n\n    const passwordForm = loginPage.body.match(/<form[^]*?<\\/form>/)[0];\n    const loginUrl = resolve(loginPageUrl, passwordForm.match(/action=\"([^\"]+)\"/)[1]); // Extract the password form's hidden fields\n\n    const loginParams = {\n      loginUrl\n    };\n    let match,\n        inputRegex = /<input.*?name=\"([^\"]+)\".*?value=\"([^\"]+)\"/g;\n\n    while (match = inputRegex.exec(passwordForm)) loginParams[match[1]] = match[2];\n\n    return loginParams;\n  }\n  /**\n   * Sends the login information to the login page.\n   *\n   * @param loginUrl string The URL of the login page\n   * @param loginParams object The login parameters\n   * @param credentials object The user's credentials\n   *\n   * @returns Promise<string> An access URL.\n   */\n\n\n  async performLogin(loginUrl, loginParams, credentials) {\n    // Set the credentials\n    loginParams.username = credentials.username;\n    loginParams.password = credentials.password; // Perform the login POST request\n\n    const options = parseUrl(loginUrl);\n    const postData = querystring.stringify(loginParams);\n    options.method = 'POST';\n    options.headers = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': postData.length\n    };\n    const loginResponse = await this.fetch(options, postData); // Verify the login was successful\n\n    if (loginResponse.statusCode !== 302) {\n      const message = loginResponse.body.match(/<strong>(.*?)<\\/strong>/);\n      const cause = message ? message[1] : 'unknown cause';\n      throw new Error(\"Could not log in: \".concat(cause));\n    } // Redirect to the authentication page, passing the session cookie\n\n\n    let authUrl = loginResponse.headers.location;\n    const cookie = loginResponse.headers['set-cookie'][0].replace(/;.*/, ''); // Handle the new consent page in 5.1.1\n\n    if (this.isAboveVersion511(loginResponse.headers['x-powered-by'])) {\n      const consentUrl = new URL(authUrl);\n      const search = consentUrl.search.substring(1);\n      let consPostData = JSON.parse('{\"' + decodeURIComponent(search).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/\\=/g, '\":\"') + '\"}');\n      consPostData.consent = true;\n      consPostData.access_mode = ['Read', 'Write', 'Append', 'Control'];\n      consPostData = querystring.stringify(consPostData);\n      const consOptions = parseUrl(\"\".concat(consentUrl.origin).concat(consentUrl.pathname));\n      consOptions.method = 'POST';\n      consOptions.headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': consPostData.length,\n        cookie\n      };\n      const consentResponse = await this.fetch(consOptions, consPostData);\n      authUrl = consentResponse.headers.location;\n    }\n\n    const authResponse = await this.fetch(Object.assign(parseUrl(authUrl), {\n      headers: {\n        cookie\n      }\n    })); // Obtain the access URL from the redirected response\n\n    const accessUrl = authResponse.headers.location;\n    return accessUrl;\n  }\n\n  isAboveVersion511(version) {\n    return /^solid-server\\/5\\.(1\\.[1-9]|[2-9]|1\\d)/.test(version);\n  }\n  /**\n   * Fetches the given resource over HTTP.\n   *\n   * @param options object The request options\n   * @param data? string The request body\n   *\n   * @returns Promise<Response> The HTTP response with a body property\n   */\n\n\n  fetch(options, data) {\n    return new Promise((resolve, reject) => {\n      const request = https.request(options);\n      request.end(data);\n      request.on('response', response => {\n        response.body = '';\n        response.on('data', data => response.body += data);\n        response.on('end', () => resolve(response));\n      });\n      request.on('error', reject);\n    });\n  }\n  /**\n   * Determines whether the session has expired.\n   *\n   * @param session object The session\n   *\n   * @returns boolean Whether the session has expired\n   */\n\n\n  isExpired(session) {\n    const now = Date.now() / 1000;\n    const expiry = session.idClaims && session.idClaims.exp || 0;\n    return expiry < now;\n  }\n\n}\n\nmodule.exports = SolidClient;","map":null,"metadata":{},"sourceType":"script"}